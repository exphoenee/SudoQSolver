"use strict";const browser=!0;class Solver{constructor(params=null){this.sectionSize=params.sectionSize||3,this.renderMyself=params.renderMyself||!1,this.cellsInSection=this.sectionSize**2,this.cells=[],this.examples={wrong:[[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9]],noSolution:[[0,1,2,3,4,5,6,7,8],[9,0,0,0,0,0,0,0,0],[8,0,0,0,0,0,0,0,0],[7,0,0,0,0,0,0,0,0],[6,0,0,0,0,0,0,0,0],[5,0,0,0,0,0,0,0,0],[4,0,0,0,0,0,0,0,0],[3,0,0,0,0,0,0,0,0],[2,0,0,0,0,0,0,0,0]],clear:[[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]],easy:[[1,0,0,0,0,7,0,0,3],[9,0,6,0,0,8,2,0,4],[0,3,0,5,2,0,0,9,0],[3,9,0,0,0,1,5,0,0],[0,0,5,0,0,0,9,0,0],[0,0,1,2,0,0,0,4,7],[0,2,0,0,6,5,0,1,0],[5,0,8,1,0,0,7,0,2],[6,0,0,7,0,0,0,0,5]],medium:[[0,8,0,0,4,0,5,7,0],[4,0,0,1,0,7,0,0,0],[5,0,0,0,9,0,0,0,0],[0,5,0,0,0,1,0,8,0],[9,0,3,0,0,0,6,0,5],[0,6,0,5,0,0,0,9,0],[0,0,0,0,8,0,0,0,3],[0,0,0,4,0,6,0,0,8],[0,1,2,0,3,0,0,6,0]],hard:[[0,0,0,4,0,5,8,9,0],[0,0,0,0,0,0,5,0,0],[0,2,0,0,0,3,7,0,0],[8,0,0,0,5,0,0,0,0],[2,0,0,0,0,7,0,3,0],[5,0,0,0,2,0,6,1,0],[4,0,0,0,0,2,0,0,0],[3,9,0,0,0,1,0,0,0],[0,7,0,0,0,0,0,0,0]],evil:[[0,4,0,2,0,0,0,7,0],[3,9,0,0,0,7,0,8,1],[7,0,6,0,0,1,4,0,2],[0,0,0,0,0,0,3,0,9],[0,0,0,0,0,0,0,0,0],[6,0,7,0,0,0,0,0,0],[1,0,4,3,0,0,8,0,5],[2,6,0,1,0,0,0,3,7],[0,8,0,0,0,2,0,6,0]]},params.renderMyself&&this.render()}solvePuzzle(puzzle=null){let startingPuzzle=this.renderMyself&&!puzzle?this.extractInputs():puzzle;if(this.isPuzzleCorrect(startingPuzzle)){const result=this.solve(startingPuzzle);if(result)return this.update(result),this.userMsg("That was easy!"),result;this.userMsg("There is no solution for this puzzle...","error")}else this.userMsg("The puzzle is not correct!","alert");return!1}solve(puzzle){return this.puzzleIsSolved(puzzle)?puzzle:this.checkPossiblities(this.validatePosiblities(this.getPosiblities(puzzle)))}validatePosiblities(puzzles){return puzzles.filter(puzzle=>this.isPuzzleCorrect(puzzle))}getPosiblities(puzzle){let possibilities=[];const nextCell=this.getNextCell(puzzle);if(nextCell)for(let nr=1;nr<=this.cellsInSection;nr++){let possibility=[...puzzle],row=[...possibility[nextCell.y]];row[nextCell.x]=nr,possibility[nextCell.y]=row,possibilities.push(possibility)}return possibilities}getNextCell(puzzle){for(let rowNr=0;rowNr<puzzle.length;rowNr++){const x=puzzle[rowNr].indexOf(0,0);if(x>-1)return{x:x,y:rowNr}}}generateMap(puzzle){return puzzle.map((row,y)=>row.map((cell,x)=>({value:cell,x:x,y:y})))}checkPossiblities(possiblities){if(possiblities.length>0){let possiblity=possiblities.shift();const treeBranch=this.solve(possiblity);return treeBranch||this.checkPossiblities(possiblities)}return!1}puzzleIsSolved(puzzle){return!puzzle.some(row=>row.some(cell=>0==cell))}isPuzzleCorrect(puzzle){const rowsCorrect=this.rowsCorrect(puzzle),columnsCorrect=this.columnsCorrect(puzzle),boxesCorrect=this.boxesCorrect(puzzle);return rowsCorrect&&columnsCorrect&&boxesCorrect}rowsCorrect(puzzle){return puzzle.every(row=>this.batchCorrect(row))}batchCorrect(batch){const onlyNums=batch.filter(num=>0!=this.validateValue(num));return new Set(onlyNums).size==onlyNums.length}columnsCorrect(puzzle){let cols;return this.getColumnsOfPuzzle(puzzle).every(col=>this.batchCorrect(col))}getColumnsOfPuzzle(puzzle){return puzzle[0].map((col,colNr)=>puzzle.map(row=>row[colNr]))}getBoxes(puzzle){let boxTemplate=[];boxTemplate=this.getColumnsOfPuzzle(puzzle.map(row=>{const boxRows=[];for(let i=0;i<row.length;i+=this.sectionSize)boxRows.push(row.slice(i,i+this.sectionSize));return boxRows}));let boxes=[];return boxTemplate.forEach(row=>{for(let j=0;j<this.cellsInSection;j+=this.sectionSize){let box=[];for(let i=0;i<this.sectionSize;i++)box=box.concat(row[j+i]);boxes.push(box)}}),boxes}boxesCorrect(puzzle){let boxes;return this.getColumnsOfPuzzle(puzzle).every(box=>this.batchCorrect(box))}update(puzzle){return this.renderMyself&&this.cells.forEach((row,rowNr)=>row.forEach((cell,colNr)=>cell.value=this.validateValue(puzzle[rowNr][colNr]))),puzzle}extractInputs(){return this.cells.map(row=>row.map(cell=>+cell.value))}validateValue(value){return value>=1&&value<=this.cellsInSection?value:""}userMsg(text,type="none"){this.renderMyself&&(this.errors.innerHTML=text);const alerting={alert:()=>alert(text),log:()=>console[type](text),error:()=>console[type](text),none:()=>null};alerting[type]()}render(){this.board=document.getElementById("board"),this.errors=document.getElementById("errors"),this.renderMyself=!0;for(let rowNr=0;rowNr<this.cellsInSection;rowNr++)this.cells.push(this.renderRow(rowNr));for(let puzzle in this.examples)this.renderButton(puzzle,()=>this.update(this.examples[puzzle]));this.renderButton("Solve!",()=>this.solvePuzzle())}renderRow(rowNr){let row=[];const rowContainer=document.createElement("div");rowContainer.classList.add(`row-${rowNr}`);for(let colNr=0;colNr<this.cellsInSection;colNr++)row.push(this.createInput(colNr,rowNr,rowContainer));return this.board.appendChild(rowContainer),row}createInput(colNr,rowNr,parent){const cell=document.createElement("input");return cell.type="number",cell.step=1,cell.min=1,cell.max=this.cellsInSection,cell.id=`C${Math.floor(1e7*Math.random()).toString().padStart(8,0)}`,cell.classList.add("tile"),cell.dataset.col=colNr,cell.dataset.row=rowNr,cell.addEventListener("change",e=>this.update(e)),parent.appendChild(cell),cell}renderButton(text,cb){const button=document.createElement("button");button.innerText=text,button.addEventListener("click",()=>{cb()}),document.getElementById("control").appendChild(button)}}{const solver=new Solver({renderMyself:!0})}
//# sourceMappingURL=app.min.js.map